---
title: "社会的選好パラメータの推定（Bruhin et al. 2019）"
author: "AI学会2025"
date: "`r Sys.Date()`"
output: 
  html_document:
    toc: true
    toc_float: true
    theme: united
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

## 1. ライブラリの読み込みとデータの準備

```{r libraries}
library(tidyverse)
library(maxLik)
```

```{r data_loading}
# AI条件のデータ読み込み
ai_data_1 <- read_csv("AI2025_data/20250117_3/dictator_app_2025-01-17.csv")
ai_data_2 <- read_csv("AI2025_data/20250120_5/dictator_app_2025-01-20.csv")

# コントロール条件のデータ読み込み
control_data_1 <- read_csv("AI2025_data/20250117_4/Base_dictator_app_2025-01-17.csv")
control_data_2 <- read_csv("AI2025_data/20250120_4/Base_dictator_app_2025-01-20.csv")

# データの前処理
process_data <- function(data, is_control = FALSE) {
  processed <- data %>%
    filter(participant.visited == 1)
  
  if (is_control) {
    processed <- processed %>%
      filter(subsession.round_number != 16)
  }
  
  return(processed)
}

# データの処理と結合
ai_data <- bind_rows(
  process_data(ai_data_1),
  process_data(ai_data_2)
) %>%
  mutate(condition = "AI")

control_data <- bind_rows(
  process_data(control_data_1, TRUE),
  process_data(control_data_2, TRUE)
) %>%
  mutate(condition = "Control")

# 全データの結合
all_data <- bind_rows(ai_data, control_data)
```

## 2. 効用関数の定義と最尤推定の準備

```{r utility_function}
# 効用関数の定義
utility_function <- function(payoff_D, payoff_R, alpha, beta) {
  # スケーリングの改善
  scale_factor <- 1000  # より大きなスケール
  payoff_D <- payoff_D / scale_factor
  payoff_R <- payoff_R / scale_factor
  
  # 不平等の計算を改善
  diff <- payoff_R - payoff_D
  total <- payoff_R + payoff_D
  relative_diff <- ifelse(total > 0, diff / total, 0)
  
  # 不平等項の計算を改善
  s <- pmax(relative_diff, 0)  
  r <- pmax(-relative_diff, 0)
  
  # 効用計算の改善
  utility <- payoff_D - alpha * s * total - beta * r * total
  
  return(utility)
}

# 選択確率の計算（ロジットモデル）
choice_probability <- function(utility_Y, utility_Z, lambda) {
  # λの範囲制限を緩和
  lambda_bounded <- min(max(lambda, 0.01), 10)
  
  # 数値的安定性の改善
  max_utility <- max(utility_Y, utility_Z)
  scaled_Y <- utility_Y - max_utility
  scaled_Z <- utility_Z - max_utility
  
  exp_Y <- exp(lambda_bounded * scaled_Y)
  exp_Z <- exp(lambda_bounded * scaled_Z)
  
  prob <- exp_Y / (exp_Y + exp_Z)
  return(pmax(pmin(prob, 0.9999), 0.0001))
}

# 対数尤度関数の修正
log_likelihood <- function(params, data) {
  alpha <- params[1]
  beta <- params[2]
  lambda <- exp(params[3])
  
  # ペナルティ項の緩和
  penalty <- 0
  if (abs(alpha) > 2) penalty <- penalty + (abs(alpha) - 2)^2
  if (abs(beta) > 2) penalty <- penalty + (abs(beta) - 2)^2
  if (lambda > 10) penalty <- penalty + (lambda - 10)^2
  
  ll <- sapply(1:nrow(data), function(i) {
    u_Y <- utility_function(
      data$payoff_Y_dictator[i],
      data$payoff_Y_receiver[i],
      alpha, beta
    )
    
    u_Z <- utility_function(
      data$payoff_Z_dictator[i],
      data$payoff_Z_receiver[i],
      alpha, beta
    )
    
    p_Y <- choice_probability(u_Y, u_Z, lambda)
    
    ifelse(data$choice_Y[i] == 1,
           log(p_Y),
           log(1 - p_Y))
  })
  
  return(mean(ll) - 0.1 * penalty)  # ペナルティの重みを調整
}

# データの前処理関数の改良
prepare_data <- function(data) {
  # データの構造を確認
  cat("利用可能な列名:\n")
  print(names(data))
  
  # 必要な列の存在確認
  required_cols <- c("player.payoff", "player.payoff_dictator", "player.payoff_receiver", "player.choice", "subsession.round_number")
  missing_cols <- setdiff(required_cols, names(data))
  if (length(missing_cols) > 0) {
    stop("Missing required columns: ", paste(missing_cols, collapse = ", "))
  }
  
  # データの要約を表示
  cat("\nデータの要約（処理前）:\n")
  print(summary(data[c("player.payoff", "player.payoff_dictator", "player.payoff_receiver", "player.choice")]))
  
  # 列名の変更とデータの整形
  processed <- data %>%
    filter(participant.visited == 1) %>%
    mutate(
      # Y選択の場合の利得
      payoff_Y_dictator = player.payoff_dictator,
      payoff_Y_receiver = player.payoff_receiver,
      # Z選択の場合の利得（player.payoffを使用）
      payoff_Z_dictator = player.payoff,
      payoff_Z_receiver = player.payoff_receiver,
      choice_Y = as.numeric(player.choice == "Y"),
      round = subsession.round_number
    ) %>%
    select(payoff_Y_dictator, payoff_Y_receiver,
           payoff_Z_dictator, payoff_Z_receiver, 
           choice_Y, round)
  
  # 欠損値の確認
  na_count <- colSums(is.na(processed))
  if (any(na_count > 0)) {
    warning("欠損値が検出されました:\n", paste(names(na_count), na_count, sep = ": ", collapse = "\n"))
  }
  
  # 異常値の確認
  cat("\n各変数の範囲:\n")
  print(summary(processed))
  
  # 完全なケースのみを保持
  processed <- processed %>% filter(complete.cases(.))
  
  # 処理後のデータサイズを表示
  cat("\n処理後のデータサイズ:", nrow(processed), "行\n")
  
  # データの一部を表示して確認
  cat("\nデータの最初の数行:\n")
  print(head(processed))
  
  return(processed)
}

# パラメータ推定関数の改良
estimate_parameters <- function(data) {
  processed_data <- prepare_data(data)
  
  if (nrow(processed_data) == 0) {
    stop("No valid data after preprocessing")
  }
  
  # デバッグログファイルの設定
  log_file <- paste0("debug_log_", format(Sys.time(), "%Y%m%d_%H%M%S"), ".txt")
  cat("デバッグログを開始します\n", file = log_file)
  
  # データの基本統計量をログに記録
  cat("\nデータの基本統計量:\n", file = log_file, append = TRUE)
  cat("サンプルサイズ:", nrow(processed_data), "\n", file = log_file, append = TRUE)
  cat("Y選択の割合:", mean(processed_data$choice_Y), "\n", file = log_file, append = TRUE)
  cat("\n支払額の範囲:\n", file = log_file, append = TRUE)
  print(summary(processed_data[, c("payoff_Y_dictator", "payoff_Y_receiver", 
                                 "payoff_Z_dictator", "payoff_Z_receiver")]), 
        file = log_file, append = TRUE)
  
  # 最適化設定の改善
  control_settings <- list(
    tol = 1e-6,          # より厳密な収束基準
    reltol = 1e-6,
    iterlim = 2000,      # より多くの反復を許可
    printLevel = 2
  )

  # より広い初期値の範囲
  alphas <- seq(-1.5, 1.5, by = 0.5)
  betas <- seq(-1.5, 1.5, by = 0.5)
  lambdas <- seq(-1, 3, by = 1)
  
  initial_values <- expand.grid(alpha = alphas, beta = betas, lambda = lambdas) %>%
    as.matrix()
  
  best_result <- NULL
  max_ll <- -Inf
  convergence_history <- list()
  
  total_iterations <- nrow(initial_values)
  cat("\n全初期値数:", total_iterations, "\n", file = log_file, append = TRUE)
  
  for (i in 1:nrow(initial_values)) {
    start_params <- initial_values[i,]
    
    cat("\n\n===== 初期値セット", i, "=====\n", file = log_file, append = TRUE)
    cat("初期値:", sprintf("%.4f ", start_params), "\n", file = log_file, append = TRUE)
    
    tryCatch({
      # まずNelder-Meadで大まかな最適化
      cat("\nNelder-Mead法による最適化開始\n", file = log_file, append = TRUE)
      result_nm <- maxLik(
        log_likelihood,
        start = start_params,
        data = processed_data,
        method = "NM",
        control = control_settings
      )
      cat("NM結果:\n", file = log_file, append = TRUE)
      print(summary(result_nm), file = log_file, append = TRUE)
      
      # 次にNRで精密化
      cat("\nNewton-Raphson法による精密化開始\n", file = log_file, append = TRUE)
      result_nr <- maxLik(
        log_likelihood,
        start = result_nm$estimate,
        data = processed_data,
        method = "NR",
        control = control_settings
      )
      cat("NR結果:\n", file = log_file, append = TRUE)
      print(summary(result_nr), file = log_file, append = TRUE)
      
      # 最後にBFGSで最終的な精密化
      cat("\nBFGS法による最終精密化開始\n", file = log_file, append = TRUE)
      result_bfgs <- maxLik(
        log_likelihood,
        start = result_nr$estimate,
        data = processed_data,
        method = "BFGS",
        control = control_settings
      )
      cat("BFGS結果:\n", file = log_file, append = TRUE)
      print(summary(result_bfgs), file = log_file, append = TRUE)
      
      # 3つの結果を比較
      results <- list(result_nm, result_nr, result_bfgs)
      valid_results <- Filter(function(x) !is.null(x$maximum), results)
      
      if (length(valid_results) > 0) {
        result <- valid_results[[which.max(sapply(valid_results, function(x) x$maximum))]]
        cat("\n最良の結果を選択:", 
            c("NM", "NR", "BFGS")[which.max(sapply(valid_results, function(x) x$maximum))], 
            "\n", file = log_file, append = TRUE)
      } else {
        result <- result_nm
        cat("\nデフォルトでNMの結果を使用\n", file = log_file, append = TRUE)
      }
      
      # 診断情報の記録
      cat("\n診断情報:\n", file = log_file, append = TRUE)
      cat("パラメータ範囲:", all(abs(result$estimate[1:2]) <= 1.5), "\n", 
          file = log_file, append = TRUE)
      cat("反復回数:", result$iterations, "\n", file = log_file, append = TRUE)
      cat("Hessian行列の状態:", !all(result$hessian == 0), "\n", 
          file = log_file, append = TRUE)
      cat("対数尤度:", result$maximum, "\n", file = log_file, append = TRUE)
      
      # より緩やかな収束判定
      params_in_range <- all(abs(result$estimate[1:2]) <= 1.5)
      enough_iterations <- result$iterations >= 1
      hessian_valid <- !all(result$hessian == 0)
      likelihood_improved <- !is.null(result$maximum) && result$maximum > max_ll
      
      if (params_in_range && enough_iterations && 
          hessian_valid && likelihood_improved) {
        
        max_ll <- result$maximum
        best_result <- result
        
        convergence_history[[length(convergence_history) + 1]] <- list(
          iteration = i,
          start_params = start_params,
          final_params = result$estimate,
          log_likelihood = result$maximum,
          iterations = result$iterations,
          hessian = result$hessian
        )
        
        cat("\n新しい最適解を記録\n", file = log_file, append = TRUE)
        cat("最終パラメータ:", sprintf("%.4f ", result$estimate), "\n", 
            file = log_file, append = TRUE)
        cat("最終対数尤度:", sprintf("%.4f", result$maximum), "\n", 
            file = log_file, append = TRUE)
      }
      
    }, error = function(e) {
      cat("\nエラー発生:", e$message, "\n", file = log_file, append = TRUE)
    })
  }
  
  if (is.null(best_result)) {
    cat("\n推定失敗: すべての初期値で収束せず\n", file = log_file, append = TRUE)
    stop("すべての初期値で推定に失敗しました")
  }
  
  # 最終結果の要約
  cat("\n\n===== 最終結果の要約 =====\n", file = log_file, append = TRUE)
  cat("最良の推定値:\n", file = log_file, append = TRUE)
  cat("α =", sprintf("%.4f", best_result$estimate[1]), "\n", 
      file = log_file, append = TRUE)
  cat("β =", sprintf("%.4f", best_result$estimate[2]), "\n", 
      file = log_file, append = TRUE)
  cat("λ =", sprintf("%.4f", exp(best_result$estimate[3])), "\n", 
      file = log_file, append = TRUE)
  cat("最終対数尤度:", sprintf("%.4f", best_result$maximum), "\n", 
      file = log_file, append = TRUE)
  
  best_result$convergence_history <- convergence_history
  best_result$debug_log_file <- log_file
  
  return(best_result)
}

# 結果の表示関数の改良
print_results <- function(condition, params) {
  cat("\n", condition, "条件の推定結果:\n")
  cat("α (不利な不平等): ", sprintf("%.4f", params$estimate[1]), "\n")
  cat("β (有利な不平等): ", sprintf("%.4f", params$estimate[2]), "\n")
  cat("λ (選択の一貫性): ", sprintf("%.4f", exp(params$estimate[3])), "\n")
  
  tryCatch({
    se <- sqrt(diag(solve(-params$hessian)))
    cat("\n標準誤差:\n")
    cat("α の標準誤差: ", sprintf("%.4f", se[1]), "\n")
    cat("β の標準誤差: ", sprintf("%.4f", se[2]), "\n")
    cat("λ の標準誤差: ", sprintf("%.4f", se[3]), "\n")
  }, error = function(e) {
    cat("\n標準誤差の計算に失敗しました\n")
    cat("Hessian行列:\n")
    print(params$hessian)
  })
  
  cat("\n収束状況:\n")
  cat("収束コード:", params$code, "\n")
  cat("反復回数:", params$iterations, "\n")
  cat("最大対数尤度:", sprintf("%.4f", params$maximum), "\n")
  
  # 追加の診断情報
  cat("\n勾配:\n")
  print(params$gradient)
}

# 可視化関数の改良
plot_parameters <- function(ai_params, control_params) {
  params_df <- data.frame(
    Condition = rep(c("AI", "Control"), each = 2),
    Parameter = rep(c("Alpha", "Beta"), 2),
    Value = c(ai_params$estimate[1:2], control_params$estimate[1:2]),
    SE = c(
      sqrt(diag(solve(-ai_params$hessian)))[1:2],
      sqrt(diag(solve(-control_params$hessian)))[1:2]
    )
  )
  
  ggplot(params_df, aes(x = Condition, y = Value, fill = Parameter)) +
    geom_bar(stat = "identity", position = position_dodge()) +
    geom_errorbar(
      aes(ymin = Value - SE, ymax = Value + SE),
      position = position_dodge(width = 0.9),
      width = 0.25
    ) +
    theme_minimal() +
    labs(
      title = "社会的選好パラメータの比較",
      subtitle = "エラーバーは標準誤差を示す",
      y = "パラメータ値",
      fill = "パラメータ"
    ) +
    scale_fill_brewer(palette = "Set2")
}
```

## 3. パラメータの推定

```{r parameter_estimation}
# データの処理と推定の実行
cat("AI条件のデータ処理と推定を開始...\n")
ai_params <- estimate_parameters(ai_data)

cat("\nControl条件のデータ処理と推定を開始...\n")
control_params <- estimate_parameters(control_data)

# 結果の表示
print_results("AI", ai_params)
print_results("Control", control_params)
```

## 4. 結果の可視化

```{r visualization}
# パラメータの比較プロット（エラーバー付き）
plot_parameters(ai_params, control_params)
```

## 5. 選好タイプの分類と解釈

```{r preference_classification}
classify_preferences <- function(alpha, beta) {
  if (abs(alpha) < 0.1 && abs(beta) < 0.1) {
    return("純粋な利己的選好")
  } else if (alpha > 0 && beta > 0) {
    if (abs(alpha - beta) < 0.1) {
      return("利他的選好")
    } else {
      return("不平等回避的選好")
    }
  } else if (alpha < 0 && beta < 0) {
    return("意地悪な選好")
  } else {
    return("混合型選好")
  }
}

# 選好タイプの判定と表示
ai_type <- classify_preferences(ai_params$estimate[1], ai_params$estimate[2])
control_type <- classify_preferences(control_params$estimate[1], control_params$estimate[2])

cat("\n選好タイプの分類結果:\n")
cat("AI条件:", ai_type, "\n")
cat("Control条件:", control_type, "\n")

# 追加の診断情報
cat("\n推定の診断情報:\n")
cat("\nAI条件:\n")
cat("収束コード:", ai_params$code, "\n")
cat("反復回数:", ai_params$iterations, "\n")
cat("最終勾配ノルム:", sqrt(sum(ai_params$gradient^2)), "\n")

cat("\nControl条件:\n")
cat("収束コード:", control_params$code, "\n")
cat("反復回数:", control_params$iterations, "\n")
cat("最終勾配ノルム:", sqrt(sum(control_params$gradient^2)), "\n")
```